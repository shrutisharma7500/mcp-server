{"version":3,"sources":["/home/runner/work/fastmcp/fastmcp/dist/edge/index.cjs","../../src/edge/index.ts","../../src/edge/WebStreamableHTTPServerTransport.ts"],"names":[],"mappings":"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","file":"/home/runner/work/fastmcp/fastmcp/dist/edge/index.cjs","sourcesContent":[null,"/**\n * FastMCP Edge Runtime Support\n *\n * This module provides edge runtime compatibility for FastMCP, enabling\n * deployment to Cloudflare Workers, Deno Deploy, and other edge platforms.\n *\n * @example\n * ```typescript\n * // Cloudflare Workers\n * import { EdgeFastMCP } from \"fastmcp/edge\";\n * import { z } from \"zod\";\n *\n * const server = new EdgeFastMCP({ name: \"MyMCP\", version: \"1.0.0\" });\n *\n * server.addTool({\n *   name: \"hello\",\n *   description: \"Say hello\",\n *   parameters: z.object({ name: z.string() }),\n *   execute: async ({ name }) => `Hello, ${name}!`,\n * });\n *\n * export default server;\n * ```\n */\n\nimport {\n  ErrorCode,\n  JSONRPCMessage,\n  LATEST_PROTOCOL_VERSION,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport { StandardSchemaV1 } from \"@standard-schema/spec\";\nimport { Hono } from \"hono\";\nimport { z } from \"zod\";\nimport { zodToJsonSchema } from \"zod-to-json-schema\";\n\nexport { WebStreamableHTTPServerTransport } from \"./WebStreamableHTTPServerTransport.js\";\nexport type {\n  EventStore,\n  WebStreamableHTTPServerTransportOptions,\n} from \"./WebStreamableHTTPServerTransport.js\";\n\n/**\n * Options for EdgeFastMCP\n */\nexport interface EdgeFastMCPOptions {\n  description?: string;\n  logger?: EdgeLogger;\n  /**\n   * Base path for MCP endpoints (default: \"/mcp\")\n   */\n  mcpPath?: string;\n  name: string;\n  version: string;\n}\n\n/**\n * Type for edge runtime fetch handler\n */\nexport type EdgeFetchHandler = (request: Request) => Promise<Response>;\n\n/**\n * Logger interface for edge environments\n */\nexport interface EdgeLogger {\n  debug(...args: unknown[]): void;\n  error(...args: unknown[]): void;\n  info(...args: unknown[]): void;\n  log(...args: unknown[]): void;\n  warn(...args: unknown[]): void;\n}\n\n/**\n * Prompt definition for EdgeFastMCP\n */\nexport interface EdgePrompt {\n  arguments?: Array<{ description?: string; name: string; required?: boolean }>;\n  description?: string;\n  load: (args: Record<string, string>) => Promise<\n    | {\n        messages: Array<{\n          content: { text: string; type: string };\n          role: string;\n        }>;\n      }\n    | string\n  >;\n  name: string;\n}\n\n/**\n * Resource definition for EdgeFastMCP\n */\nexport interface EdgeResource {\n  description?: string;\n  load: () => Promise<\n    { blob?: string; mimeType?: string; text?: string } | string\n  >;\n  mimeType?: string;\n  name: string;\n  uri: string;\n}\n\n/**\n * Tool definition for EdgeFastMCP\n */\nexport interface EdgeTool<TParams = unknown> {\n  description: string;\n  execute: (params: TParams) => Promise<\n    | {\n        content: Array<{\n          data?: string;\n          mimeType?: string;\n          text?: string;\n          type: string;\n        }>;\n      }\n    | string\n  >;\n  name: string;\n  parameters?: StandardSchemaV1<TParams> | z.ZodType<TParams>;\n}\n\n/**\n * Edge-compatible FastMCP server for Cloudflare Workers, Deno, and Bun\n *\n * This is a simplified implementation optimized for stateless edge environments.\n * It uses web-standard APIs only (no Node.js dependencies).\n */\nexport class EdgeFastMCP {\n  #honoApp = new Hono();\n  #logger: EdgeLogger;\n  #mcpPath: string;\n  #name: string;\n  #prompts: EdgePrompt[] = [];\n  #resources: EdgeResource[] = [];\n  #tools: EdgeTool[] = [];\n  #version: string;\n\n  constructor(options: EdgeFastMCPOptions) {\n    this.#name = options.name;\n    this.#version = options.version;\n    this.#logger = options.logger ?? console;\n    this.#mcpPath = options.mcpPath ?? \"/mcp\";\n\n    this.#setupRoutes();\n  }\n\n  /**\n   * Add a prompt to the server\n   */\n  addPrompt(prompt: EdgePrompt): this {\n    this.#prompts.push(prompt);\n    return this;\n  }\n\n  /**\n   * Add a resource to the server\n   */\n  addResource(resource: EdgeResource): this {\n    this.#resources.push(resource);\n    return this;\n  }\n\n  /**\n   * Add a tool to the server\n   */\n  addTool<TParams>(tool: EdgeTool<TParams>): this {\n    this.#tools.push(tool as EdgeTool);\n    return this;\n  }\n\n  /**\n   * Handle an incoming request (main entry point for edge runtimes)\n   */\n  async fetch(request: Request): Promise<Response> {\n    return this.#honoApp.fetch(request);\n  }\n\n  /**\n   * Get the Hono app for adding custom routes\n   */\n  getApp(): Hono {\n    return this.#honoApp;\n  }\n\n  /**\n   * Create an error HTTP response\n   */\n  #errorResponse(status: number, code: number, message: string): Response {\n    return new Response(\n      JSON.stringify({\n        error: { code, message },\n        id: null,\n        jsonrpc: \"2.0\",\n      }),\n      {\n        headers: { \"Content-Type\": \"application/json\" },\n        status,\n      },\n    );\n  }\n\n  /**\n   * Handle initialize request\n   */\n  #handleInitialize(id: number | string): JSONRPCMessage {\n    return {\n      id,\n      jsonrpc: \"2.0\",\n      result: {\n        capabilities: {\n          prompts: this.#prompts.length > 0 ? {} : undefined,\n          resources: this.#resources.length > 0 ? {} : undefined,\n          tools: this.#tools.length > 0 ? {} : undefined,\n        },\n        protocolVersion: LATEST_PROTOCOL_VERSION,\n        serverInfo: {\n          name: this.#name,\n          version: this.#version,\n        },\n      },\n    } as JSONRPCMessage;\n  }\n\n  /**\n   * Handle MCP POST requests\n   */\n  async #handleMcpRequest(request: Request): Promise<Response> {\n    // Validate headers\n    const acceptHeader = request.headers.get(\"accept\");\n    if (\n      !acceptHeader?.includes(\"application/json\") &&\n      !acceptHeader?.includes(\"text/event-stream\")\n    ) {\n      return this.#errorResponse(\n        406,\n        -32000,\n        \"Not Acceptable: Client must accept application/json or text/event-stream\",\n      );\n    }\n\n    const contentType = request.headers.get(\"content-type\");\n    if (!contentType?.includes(\"application/json\")) {\n      return this.#errorResponse(\n        415,\n        -32000,\n        \"Unsupported Media Type: Content-Type must be application/json\",\n      );\n    }\n\n    // Parse request body\n    let body: unknown;\n    try {\n      body = await request.json();\n    } catch {\n      return this.#errorResponse(400, -32700, \"Parse error: Invalid JSON\");\n    }\n\n    // Handle single or batch requests\n    const messages = Array.isArray(body) ? body : [body];\n    const responses: JSONRPCMessage[] = [];\n\n    for (const message of messages) {\n      const response = await this.#handleMessage(message);\n      if (response) {\n        responses.push(response);\n      }\n    }\n\n    // Return appropriate response format\n    if (responses.length === 0) {\n      return new Response(null, { status: 202 });\n    }\n\n    const responseBody =\n      responses.length === 1\n        ? JSON.stringify(responses[0])\n        : JSON.stringify(responses);\n\n    return new Response(responseBody, {\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      status: 200,\n    });\n  }\n\n  /**\n   * Handle SSE GET requests\n   */\n  async #handleMcpSseRequest(request: Request): Promise<Response> {\n    const acceptHeader = request.headers.get(\"accept\");\n    if (!acceptHeader?.includes(\"text/event-stream\")) {\n      return this.#errorResponse(\n        406,\n        -32000,\n        \"Not Acceptable: Client must accept text/event-stream\",\n      );\n    }\n\n    // In stateless mode, GET requests are not supported (no server-initiated messages)\n    return this.#errorResponse(\n      405,\n      -32000,\n      \"Method Not Allowed: SSE streams not supported in stateless mode\",\n    );\n  }\n\n  /**\n   * Handle individual MCP messages\n   */\n  async #handleMessage(message: unknown): Promise<JSONRPCMessage | null> {\n    if (!message || typeof message !== \"object\") {\n      return this.#rpcError(null, -32700, \"Parse error: Invalid message\");\n    }\n\n    const msg = message as {\n      id?: number | string;\n      jsonrpc?: string;\n      method?: string;\n      params?: unknown;\n    };\n\n    if (msg.jsonrpc !== \"2.0\") {\n      return this.#rpcError(\n        msg.id ?? null,\n        -32600,\n        \"Invalid Request: jsonrpc must be 2.0\",\n      );\n    }\n\n    // Handle notifications (no response expected)\n    if (!(\"id\" in msg) || msg.id === undefined) {\n      return null;\n    }\n\n    const method = msg.method;\n    const id = msg.id;\n    const params = msg.params as Record<string, unknown> | undefined;\n\n    try {\n      switch (method) {\n        case \"initialize\":\n          return this.#handleInitialize(id);\n\n        case \"ping\":\n          return { id, jsonrpc: \"2.0\", result: {} } as JSONRPCMessage;\n\n        case \"prompts/get\":\n          return this.#handlePromptsGet(id, params);\n\n        case \"prompts/list\":\n          return this.#handlePromptsList(id);\n\n        case \"resources/list\":\n          return this.#handleResourcesList(id);\n\n        case \"resources/read\":\n          return this.#handleResourcesRead(id, params);\n\n        case \"tools/call\":\n          return this.#handleToolsCall(id, params);\n\n        case \"tools/list\":\n          return this.#handleToolsList(id);\n\n        default:\n          return this.#rpcError(id, -32601, `Method not found: ${method}`);\n      }\n    } catch (error) {\n      this.#logger.error(`Error handling ${method}:`, error);\n      return this.#rpcError(\n        id,\n        -32603,\n        `Internal error: ${error instanceof Error ? error.message : String(error)}`,\n      );\n    }\n  }\n\n  /**\n   * Handle prompts/get request\n   */\n  async #handlePromptsGet(\n    id: number | string,\n    params?: Record<string, unknown>,\n  ): Promise<JSONRPCMessage> {\n    const promptName = params?.name as string;\n    const promptArgs = params?.arguments as Record<string, string> | undefined;\n\n    const prompt = this.#prompts.find((p) => p.name === promptName);\n    if (!prompt) {\n      return this.#rpcError(\n        id,\n        ErrorCode.InvalidParams,\n        `Prompt not found: ${promptName}`,\n      );\n    }\n\n    try {\n      const result = await prompt.load(promptArgs ?? {});\n      const messages =\n        typeof result === \"string\"\n          ? [{ content: { text: result, type: \"text\" }, role: \"user\" }]\n          : result.messages;\n\n      return {\n        id,\n        jsonrpc: \"2.0\",\n        result: { messages },\n      } as JSONRPCMessage;\n    } catch (error) {\n      return this.#rpcError(\n        id,\n        ErrorCode.InternalError,\n        `Prompt load failed: ${error instanceof Error ? error.message : String(error)}`,\n      );\n    }\n  }\n\n  /**\n   * Handle prompts/list request\n   */\n  #handlePromptsList(id: number | string): JSONRPCMessage {\n    return {\n      id,\n      jsonrpc: \"2.0\",\n      result: {\n        prompts: this.#prompts.map((p) => ({\n          arguments: p.arguments,\n          description: p.description,\n          name: p.name,\n        })),\n      },\n    } as JSONRPCMessage;\n  }\n\n  /**\n   * Handle resources/list request\n   */\n  #handleResourcesList(id: number | string): JSONRPCMessage {\n    return {\n      id,\n      jsonrpc: \"2.0\",\n      result: {\n        resources: this.#resources.map((r) => ({\n          description: r.description,\n          mimeType: r.mimeType,\n          name: r.name,\n          uri: r.uri,\n        })),\n      },\n    } as JSONRPCMessage;\n  }\n\n  /**\n   * Handle resources/read request\n   */\n  async #handleResourcesRead(\n    id: number | string,\n    params?: Record<string, unknown>,\n  ): Promise<JSONRPCMessage> {\n    const uri = params?.uri as string;\n    const resource = this.#resources.find((r) => r.uri === uri);\n\n    if (!resource) {\n      return this.#rpcError(\n        id,\n        ErrorCode.InvalidParams,\n        `Resource not found: ${uri}`,\n      );\n    }\n\n    try {\n      const result = await resource.load();\n      const content =\n        typeof result === \"string\"\n          ? { mimeType: resource.mimeType ?? \"text/plain\", text: result, uri }\n          : { uri, ...result };\n\n      return {\n        id,\n        jsonrpc: \"2.0\",\n        result: { contents: [content] },\n      } as JSONRPCMessage;\n    } catch (error) {\n      return this.#rpcError(\n        id,\n        ErrorCode.InternalError,\n        `Resource load failed: ${error instanceof Error ? error.message : String(error)}`,\n      );\n    }\n  }\n\n  /**\n   * Handle tools/call request\n   */\n  async #handleToolsCall(\n    id: number | string,\n    params?: Record<string, unknown>,\n  ): Promise<JSONRPCMessage> {\n    const toolName = params?.name as string;\n    const toolArgs = params?.arguments as Record<string, unknown> | undefined;\n\n    const tool = this.#tools.find((t) => t.name === toolName);\n    if (!tool) {\n      return this.#rpcError(\n        id,\n        ErrorCode.InvalidParams,\n        `Tool not found: ${toolName}`,\n      );\n    }\n\n    try {\n      const result = await tool.execute(toolArgs ?? {});\n\n      // Normalize result to content array\n      const content =\n        typeof result === \"string\"\n          ? [{ text: result, type: \"text\" }]\n          : result.content;\n\n      return {\n        id,\n        jsonrpc: \"2.0\",\n        result: { content },\n      } as JSONRPCMessage;\n    } catch (error) {\n      return this.#rpcError(\n        id,\n        ErrorCode.InternalError,\n        `Tool execution failed: ${error instanceof Error ? error.message : String(error)}`,\n      );\n    }\n  }\n\n  /**\n   * Handle tools/list request\n   */\n  #handleToolsList(id: number | string): JSONRPCMessage {\n    return {\n      id,\n      jsonrpc: \"2.0\",\n      result: {\n        tools: this.#tools.map((tool) => ({\n          description: tool.description,\n          inputSchema: tool.parameters\n            ? this.#schemaToJsonSchema(tool.parameters)\n            : { type: \"object\" },\n          name: tool.name,\n        })),\n      },\n    } as JSONRPCMessage;\n  }\n\n  /**\n   * Create an RPC error message\n   */\n  #rpcError(\n    id: null | number | string,\n    code: number,\n    message: string,\n  ): JSONRPCMessage {\n    return {\n      error: { code, message },\n      id,\n      jsonrpc: \"2.0\",\n    } as JSONRPCMessage;\n  }\n\n  /**\n   * Convert schema to JSON Schema\n   */\n  #schemaToJsonSchema(\n    schema: StandardSchemaV1 | z.ZodType,\n  ): Record<string, unknown> {\n    try {\n      // Zod 4+: use native toJSONSchema if available\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      if (typeof (z as any).toJSONSchema === \"function\") {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return (z as any).toJSONSchema(schema) as Record<string, unknown>;\n      }\n      // Zod 3 fallback: use zod-to-json-schema\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      if (\"_def\" in (schema as any) || schema instanceof z.ZodType) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return zodToJsonSchema(schema as any, { target: \"openApi3\" }) as Record<\n          string,\n          unknown\n        >;\n      }\n      // For StandardSchema, fall back to a generic object schema\n      return { type: \"object\" };\n    } catch {\n      return { type: \"object\" };\n    }\n  }\n\n  /**\n   * Set up MCP and health routes\n   */\n  #setupRoutes(): void {\n    // Health endpoint\n    this.#honoApp.get(\"/health\", (c) => c.text(\"âœ“ Ok\"));\n\n    // MCP endpoint - handles all MCP protocol messages\n    this.#honoApp.post(this.#mcpPath, async (c) => {\n      return this.#handleMcpRequest(c.req.raw);\n    });\n\n    // MCP GET endpoint for SSE streams (server-initiated messages)\n    this.#honoApp.get(this.#mcpPath, async (c) => {\n      return this.#handleMcpSseRequest(c.req.raw);\n    });\n\n    // MCP DELETE endpoint for session termination\n    this.#honoApp.delete(this.#mcpPath, async () => {\n      return new Response(null, { status: 204 });\n    });\n  }\n}\n","/**\n * Web-standard Streamable HTTP Server Transport for MCP\n *\n * This transport implements the MCP Streamable HTTP specification using\n * web standard APIs (Request, Response, TransformStream) for compatibility\n * with edge runtimes like Cloudflare Workers, Deno, and Bun.\n */\n\nimport { Transport } from \"@modelcontextprotocol/sdk/shared/transport.js\";\nimport {\n  isInitializeRequest,\n  isJSONRPCNotification,\n  isJSONRPCResponse,\n  JSONRPCMessage,\n  JSONRPCMessageSchema,\n  MessageExtraInfo,\n  RequestId,\n} from \"@modelcontextprotocol/sdk/types.js\";\n\nexport type EventId = string;\n/**\n * Interface for resumability support via event storage\n */\nexport interface EventStore {\n  getStreamIdForEventId?(eventId: EventId): Promise<StreamId | undefined>;\n  replayEventsAfter(\n    lastEventId: EventId,\n    options: {\n      send: (eventId: EventId, message: JSONRPCMessage) => Promise<void>;\n    },\n  ): Promise<StreamId>;\n  storeEvent(streamId: StreamId, message: JSONRPCMessage): Promise<EventId>;\n}\n\nexport type StreamId = string;\n\n/**\n * Configuration options for WebStreamableHTTPServerTransport\n */\nexport interface WebStreamableHTTPServerTransportOptions {\n  /**\n   * If true, return JSON responses instead of SSE streams\n   */\n  enableJsonResponse?: boolean;\n\n  /**\n   * Event store for resumability support\n   */\n  eventStore?: EventStore;\n\n  /**\n   * Callback for session close events\n   */\n  onsessionclosed?: (sessionId: string) => Promise<void> | void;\n\n  /**\n   * Callback for session initialization events\n   */\n  onsessioninitialized?: (sessionId: string) => Promise<void> | void;\n\n  /**\n   * Function that generates a session ID for the transport.\n   * Return undefined to disable session management (stateless mode).\n   */\n  sessionIdGenerator: (() => string) | undefined;\n}\n\nconst MAXIMUM_MESSAGE_SIZE = 4 * 1024 * 1024; // 4MB\n\n/**\n * Web-standard Server transport for Streamable HTTP.\n * Uses web APIs (Request, Response, TransformStream) for edge runtime compatibility.\n */\nexport class WebStreamableHTTPServerTransport implements Transport {\n  onclose?: () => void;\n  onerror?: (error: Error) => void;\n  onmessage?: (message: JSONRPCMessage, extra?: MessageExtraInfo) => void;\n  sessionId?: string;\n  private _enableJsonResponse = false;\n  private _encoder = new TextEncoder();\n  private _eventStore?: EventStore;\n  private _onsessionclosed?: (sessionId: string) => Promise<void> | void;\n  private _onsessioninitialized?: (sessionId: string) => Promise<void> | void;\n  private _pendingResponses: JSONRPCMessage[] = [];\n  private _requestToStreamMapping = new Map<RequestId, StreamId>();\n\n  private _standaloneSseStreamId = \"_GET_stream\";\n  private _started = false;\n  private _streamMapping = new Map<\n    StreamId,\n    WritableStreamDefaultWriter<Uint8Array>\n  >();\n  private sessionIdGenerator: (() => string) | undefined;\n\n  constructor(options: WebStreamableHTTPServerTransportOptions) {\n    this.sessionIdGenerator = options.sessionIdGenerator;\n    this._enableJsonResponse = options.enableJsonResponse ?? false;\n    this._eventStore = options.eventStore;\n    this._onsessioninitialized = options.onsessioninitialized;\n    this._onsessionclosed = options.onsessionclosed;\n  }\n\n  /**\n   * Close the transport\n   */\n  async close(): Promise<void> {\n    for (const writer of this._streamMapping.values()) {\n      try {\n        await writer.close();\n      } catch {\n        // Ignore close errors\n      }\n    }\n    this._streamMapping.clear();\n    this._started = false;\n    this.onclose?.();\n  }\n\n  /**\n   * Handles an incoming web Request and returns a Response\n   */\n  async handleRequest(\n    request: Request,\n    parsedBody?: unknown,\n  ): Promise<Response> {\n    const method = request.method;\n\n    if (method === \"POST\") {\n      return this.handlePostRequest(request, parsedBody);\n    } else if (method === \"GET\") {\n      return this.handleGetRequest(request);\n    } else if (method === \"DELETE\") {\n      return this.handleDeleteRequest(request);\n    } else {\n      return this.handleUnsupportedRequest();\n    }\n  }\n\n  /**\n   * Send a message to connected clients\n   */\n  async send(\n    message: JSONRPCMessage,\n    options?: { relatedRequestId?: RequestId },\n  ): Promise<void> {\n    // Store for pending responses (used in JSON response mode)\n    this._pendingResponses.push(message);\n\n    // Send to SSE streams\n    const streamId = options?.relatedRequestId\n      ? this._requestToStreamMapping.get(options.relatedRequestId)\n      : this._standaloneSseStreamId;\n\n    if (streamId) {\n      const writer = this._streamMapping.get(streamId);\n      if (writer) {\n        try {\n          if (this._eventStore) {\n            const eventId = await this._eventStore.storeEvent(\n              streamId,\n              message,\n            );\n            await this.writeSSEEventWithId(writer, eventId, message);\n          } else {\n            await this.writeSSEEvent(writer, message);\n          }\n        } catch (error) {\n          this.onerror?.(\n            error instanceof Error ? error : new Error(String(error)),\n          );\n        }\n      }\n    }\n  }\n\n  async start(): Promise<void> {\n    if (this._started) {\n      throw new Error(\"Transport already started\");\n    }\n    this._started = true;\n  }\n\n  /**\n   * Create an error response\n   */\n  private createErrorResponse(\n    status: number,\n    code: number,\n    message: string,\n  ): Response {\n    return new Response(\n      JSON.stringify({\n        error: { code, message },\n        id: null,\n        jsonrpc: \"2.0\",\n      }),\n      {\n        headers: {\n          ...this.getResponseHeaders(),\n          \"Content-Type\": \"application/json\",\n        },\n        status,\n      },\n    );\n  }\n\n  /**\n   * Get common response headers\n   */\n  private getResponseHeaders(): Record<string, string> {\n    const headers: Record<string, string> = {};\n    if (this.sessionId) {\n      headers[\"mcp-session-id\"] = this.sessionId;\n    }\n    return headers;\n  }\n\n  /**\n   * Handles DELETE requests to terminate sessions\n   */\n  private async handleDeleteRequest(request: Request): Promise<Response> {\n    const sessionId = request.headers.get(\"mcp-session-id\");\n\n    if (this.sessionIdGenerator) {\n      if (!sessionId) {\n        return this.createErrorResponse(\n          400,\n          -32000,\n          \"Bad Request: Mcp-Session-Id header is required\",\n        );\n      }\n\n      if (this.sessionId !== sessionId) {\n        return this.createErrorResponse(404, -32001, \"Session not found\");\n      }\n    }\n\n    // Close all streams\n    for (const writer of this._streamMapping.values()) {\n      try {\n        await writer.close();\n      } catch {\n        // Ignore close errors\n      }\n    }\n    this._streamMapping.clear();\n\n    await this._onsessionclosed?.(this.sessionId ?? \"\");\n    this.sessionId = undefined;\n\n    return new Response(null, {\n      headers: this.getResponseHeaders(),\n      status: 204,\n    });\n  }\n\n  /**\n   * Handles GET requests for SSE stream\n   */\n  private async handleGetRequest(request: Request): Promise<Response> {\n    const acceptHeader = request.headers.get(\"accept\");\n    if (!acceptHeader?.includes(\"text/event-stream\")) {\n      return this.createErrorResponse(\n        406,\n        -32000,\n        \"Not Acceptable: Client must accept text/event-stream\",\n      );\n    }\n\n    // Validate session\n    const sessionId = request.headers.get(\"mcp-session-id\");\n    if (this.sessionIdGenerator && !sessionId) {\n      return this.createErrorResponse(\n        400,\n        -32000,\n        \"Bad Request: Mcp-Session-Id header is required\",\n      );\n    }\n\n    if (this.sessionIdGenerator && this.sessionId !== sessionId) {\n      return this.createErrorResponse(404, -32001, \"Session not found\");\n    }\n\n    // Check for existing standalone stream\n    if (this._streamMapping.has(this._standaloneSseStreamId)) {\n      return this.createErrorResponse(\n        409,\n        -32000,\n        \"Conflict: SSE stream already exists for this session\",\n      );\n    }\n\n    // Handle resumability\n    if (this._eventStore) {\n      const lastEventId = request.headers.get(\"last-event-id\");\n      if (lastEventId) {\n        return this.handleReplayEvents(lastEventId);\n      }\n    }\n\n    // Create SSE stream\n    const { readable, writable } = new TransformStream<Uint8Array>();\n    const writer = writable.getWriter();\n    this._streamMapping.set(this._standaloneSseStreamId, writer);\n\n    return new Response(readable, {\n      headers: {\n        ...this.getResponseHeaders(),\n        \"Cache-Control\": \"no-cache, no-transform\",\n        Connection: \"keep-alive\",\n        \"Content-Type\": \"text/event-stream\",\n      },\n      status: 200,\n    });\n  }\n\n  /**\n   * Handles POST requests containing JSON-RPC messages\n   */\n  private async handlePostRequest(\n    request: Request,\n    parsedBody?: unknown,\n  ): Promise<Response> {\n    // Validate Accept header\n    const acceptHeader = request.headers.get(\"accept\");\n    if (\n      !acceptHeader?.includes(\"application/json\") &&\n      !acceptHeader?.includes(\"text/event-stream\")\n    ) {\n      return this.createErrorResponse(\n        406,\n        -32000,\n        \"Not Acceptable: Client must accept application/json or text/event-stream\",\n      );\n    }\n\n    // Validate Content-Type\n    const contentType = request.headers.get(\"content-type\");\n    if (!contentType?.includes(\"application/json\")) {\n      return this.createErrorResponse(\n        415,\n        -32000,\n        \"Unsupported Media Type: Content-Type must be application/json\",\n      );\n    }\n\n    // Validate Content-Length\n    const contentLength = parseInt(\n      request.headers.get(\"content-length\") ?? \"0\",\n      10,\n    );\n    if (contentLength > MAXIMUM_MESSAGE_SIZE) {\n      return this.createErrorResponse(\n        413,\n        -32000,\n        `Request body too large. Maximum size is ${MAXIMUM_MESSAGE_SIZE} bytes`,\n      );\n    }\n\n    // Parse body\n    let rawMessage: unknown;\n    try {\n      rawMessage = parsedBody ?? (await request.json());\n    } catch {\n      return this.createErrorResponse(400, -32700, \"Parse error: Invalid JSON\");\n    }\n\n    // Handle batch or single message\n    const arrayMessage: unknown[] = Array.isArray(rawMessage)\n      ? rawMessage\n      : [rawMessage];\n\n    // Validate messages\n    const messages: JSONRPCMessage[] = [];\n    for (const msg of arrayMessage) {\n      const result = JSONRPCMessageSchema.safeParse(msg);\n      if (!result.success) {\n        return this.createErrorResponse(\n          400,\n          -32700,\n          \"Parse error: Invalid JSON-RPC message\",\n        );\n      }\n      messages.push(result.data);\n    }\n\n    // Handle session ID\n    const requestSessionId = request.headers.get(\"mcp-session-id\");\n    const hasInitRequest = messages.some((msg) => isInitializeRequest(msg));\n\n    // Validate session requirements\n    if (hasInitRequest && requestSessionId) {\n      return this.createErrorResponse(\n        400,\n        -32600,\n        \"Invalid Request: Initialization requests must not include a sessionId\",\n      );\n    }\n\n    if (hasInitRequest && messages.length > 1) {\n      return this.createErrorResponse(\n        400,\n        -32600,\n        \"Invalid Request: Only one initialization request is allowed\",\n      );\n    }\n\n    if (!hasInitRequest && !requestSessionId && this.sessionIdGenerator) {\n      return this.createErrorResponse(\n        400,\n        -32000,\n        \"Bad Request: Mcp-Session-Id header is required\",\n      );\n    }\n\n    // Generate or validate session ID\n    if (hasInitRequest && this.sessionIdGenerator) {\n      this.sessionId = this.sessionIdGenerator();\n      await this._onsessioninitialized?.(this.sessionId);\n    } else if (requestSessionId) {\n      if (this.sessionIdGenerator && this.sessionId !== requestSessionId) {\n        return this.createErrorResponse(404, -32001, \"Session not found\");\n      }\n    }\n\n    // Process messages through the transport\n    this._pendingResponses = [];\n    for (const message of messages) {\n      this.onmessage?.(message, { authInfo: undefined });\n    }\n\n    // If all messages are notifications/responses, return 202\n    if (\n      messages.every(\n        (msg) => isJSONRPCNotification(msg) || isJSONRPCResponse(msg),\n      )\n    ) {\n      return new Response(null, {\n        headers: this.getResponseHeaders(),\n        status: 202,\n      });\n    }\n\n    // Return JSON response if enabled and client accepts it\n    if (\n      this._enableJsonResponse &&\n      acceptHeader?.includes(\"application/json\")\n    ) {\n      // Wait a tick for responses to be collected\n      await new Promise((resolve) => setTimeout(resolve, 0));\n\n      const responseBody =\n        this._pendingResponses.length === 1\n          ? JSON.stringify(this._pendingResponses[0])\n          : JSON.stringify(this._pendingResponses);\n\n      return new Response(responseBody, {\n        headers: {\n          ...this.getResponseHeaders(),\n          \"Content-Type\": \"application/json\",\n        },\n        status: 200,\n      });\n    }\n\n    // Return SSE stream\n    const { readable, writable } = new TransformStream<Uint8Array>();\n    const writer = writable.getWriter();\n    const streamId = `post_${Date.now()}`;\n    this._streamMapping.set(streamId, writer);\n\n    // Send any pending responses as SSE events\n    (async () => {\n      try {\n        for (const response of this._pendingResponses) {\n          await this.writeSSEEvent(writer, response);\n        }\n      } catch (error) {\n        this.onerror?.(\n          error instanceof Error ? error : new Error(String(error)),\n        );\n      }\n    })();\n\n    return new Response(readable, {\n      headers: {\n        ...this.getResponseHeaders(),\n        \"Cache-Control\": \"no-cache, no-transform\",\n        Connection: \"keep-alive\",\n        \"Content-Type\": \"text/event-stream\",\n      },\n      status: 200,\n    });\n  }\n\n  /**\n   * Replay events for resumability\n   */\n  private async handleReplayEvents(lastEventId: string): Promise<Response> {\n    if (!this._eventStore) {\n      return this.createErrorResponse(\n        400,\n        -32000,\n        \"Resumability not supported\",\n      );\n    }\n\n    const { readable, writable } = new TransformStream<Uint8Array>();\n    const writer = writable.getWriter();\n\n    try {\n      const streamId = await this._eventStore.replayEventsAfter(lastEventId, {\n        send: async (eventId, message) => {\n          await this.writeSSEEventWithId(writer, eventId, message);\n        },\n      });\n      this._streamMapping.set(streamId, writer);\n    } catch (error) {\n      await writer.close();\n      return this.createErrorResponse(500, -32000, `Replay failed: ${error}`);\n    }\n\n    return new Response(readable, {\n      headers: {\n        ...this.getResponseHeaders(),\n        \"Cache-Control\": \"no-cache, no-transform\",\n        Connection: \"keep-alive\",\n        \"Content-Type\": \"text/event-stream\",\n      },\n      status: 200,\n    });\n  }\n\n  /**\n   * Handles unsupported HTTP methods\n   */\n  private handleUnsupportedRequest(): Response {\n    return this.createErrorResponse(405, -32000, \"Method not allowed\");\n  }\n\n  /**\n   * Write an SSE event to the stream\n   */\n  private async writeSSEEvent(\n    writer: WritableStreamDefaultWriter<Uint8Array>,\n    message: JSONRPCMessage,\n  ): Promise<void> {\n    const data = `data: ${JSON.stringify(message)}\\n\\n`;\n    await writer.write(this._encoder.encode(data));\n  }\n\n  /**\n   * Write an SSE event with ID to the stream\n   */\n  private async writeSSEEventWithId(\n    writer: WritableStreamDefaultWriter<Uint8Array>,\n    eventId: string,\n    message: JSONRPCMessage,\n  ): Promise<void> {\n    const data = `id: ${eventId}\\ndata: ${JSON.stringify(message)}\\n\\n`;\n    await writer.write(this._encoder.encode(data));\n  }\n}\n"]}