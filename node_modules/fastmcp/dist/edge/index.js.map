{"version":3,"sources":["../../src/edge/index.ts","../../src/edge/WebStreamableHTTPServerTransport.ts"],"sourcesContent":["/**\n * FastMCP Edge Runtime Support\n *\n * This module provides edge runtime compatibility for FastMCP, enabling\n * deployment to Cloudflare Workers, Deno Deploy, and other edge platforms.\n *\n * @example\n * ```typescript\n * // Cloudflare Workers\n * import { EdgeFastMCP } from \"fastmcp/edge\";\n * import { z } from \"zod\";\n *\n * const server = new EdgeFastMCP({ name: \"MyMCP\", version: \"1.0.0\" });\n *\n * server.addTool({\n *   name: \"hello\",\n *   description: \"Say hello\",\n *   parameters: z.object({ name: z.string() }),\n *   execute: async ({ name }) => `Hello, ${name}!`,\n * });\n *\n * export default server;\n * ```\n */\n\nimport {\n  ErrorCode,\n  JSONRPCMessage,\n  LATEST_PROTOCOL_VERSION,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport { StandardSchemaV1 } from \"@standard-schema/spec\";\nimport { Hono } from \"hono\";\nimport { z } from \"zod\";\nimport { zodToJsonSchema } from \"zod-to-json-schema\";\n\nexport { WebStreamableHTTPServerTransport } from \"./WebStreamableHTTPServerTransport.js\";\nexport type {\n  EventStore,\n  WebStreamableHTTPServerTransportOptions,\n} from \"./WebStreamableHTTPServerTransport.js\";\n\n/**\n * Options for EdgeFastMCP\n */\nexport interface EdgeFastMCPOptions {\n  description?: string;\n  logger?: EdgeLogger;\n  /**\n   * Base path for MCP endpoints (default: \"/mcp\")\n   */\n  mcpPath?: string;\n  name: string;\n  version: string;\n}\n\n/**\n * Type for edge runtime fetch handler\n */\nexport type EdgeFetchHandler = (request: Request) => Promise<Response>;\n\n/**\n * Logger interface for edge environments\n */\nexport interface EdgeLogger {\n  debug(...args: unknown[]): void;\n  error(...args: unknown[]): void;\n  info(...args: unknown[]): void;\n  log(...args: unknown[]): void;\n  warn(...args: unknown[]): void;\n}\n\n/**\n * Prompt definition for EdgeFastMCP\n */\nexport interface EdgePrompt {\n  arguments?: Array<{ description?: string; name: string; required?: boolean }>;\n  description?: string;\n  load: (args: Record<string, string>) => Promise<\n    | {\n        messages: Array<{\n          content: { text: string; type: string };\n          role: string;\n        }>;\n      }\n    | string\n  >;\n  name: string;\n}\n\n/**\n * Resource definition for EdgeFastMCP\n */\nexport interface EdgeResource {\n  description?: string;\n  load: () => Promise<\n    { blob?: string; mimeType?: string; text?: string } | string\n  >;\n  mimeType?: string;\n  name: string;\n  uri: string;\n}\n\n/**\n * Tool definition for EdgeFastMCP\n */\nexport interface EdgeTool<TParams = unknown> {\n  description: string;\n  execute: (params: TParams) => Promise<\n    | {\n        content: Array<{\n          data?: string;\n          mimeType?: string;\n          text?: string;\n          type: string;\n        }>;\n      }\n    | string\n  >;\n  name: string;\n  parameters?: StandardSchemaV1<TParams> | z.ZodType<TParams>;\n}\n\n/**\n * Edge-compatible FastMCP server for Cloudflare Workers, Deno, and Bun\n *\n * This is a simplified implementation optimized for stateless edge environments.\n * It uses web-standard APIs only (no Node.js dependencies).\n */\nexport class EdgeFastMCP {\n  #honoApp = new Hono();\n  #logger: EdgeLogger;\n  #mcpPath: string;\n  #name: string;\n  #prompts: EdgePrompt[] = [];\n  #resources: EdgeResource[] = [];\n  #tools: EdgeTool[] = [];\n  #version: string;\n\n  constructor(options: EdgeFastMCPOptions) {\n    this.#name = options.name;\n    this.#version = options.version;\n    this.#logger = options.logger ?? console;\n    this.#mcpPath = options.mcpPath ?? \"/mcp\";\n\n    this.#setupRoutes();\n  }\n\n  /**\n   * Add a prompt to the server\n   */\n  addPrompt(prompt: EdgePrompt): this {\n    this.#prompts.push(prompt);\n    return this;\n  }\n\n  /**\n   * Add a resource to the server\n   */\n  addResource(resource: EdgeResource): this {\n    this.#resources.push(resource);\n    return this;\n  }\n\n  /**\n   * Add a tool to the server\n   */\n  addTool<TParams>(tool: EdgeTool<TParams>): this {\n    this.#tools.push(tool as EdgeTool);\n    return this;\n  }\n\n  /**\n   * Handle an incoming request (main entry point for edge runtimes)\n   */\n  async fetch(request: Request): Promise<Response> {\n    return this.#honoApp.fetch(request);\n  }\n\n  /**\n   * Get the Hono app for adding custom routes\n   */\n  getApp(): Hono {\n    return this.#honoApp;\n  }\n\n  /**\n   * Create an error HTTP response\n   */\n  #errorResponse(status: number, code: number, message: string): Response {\n    return new Response(\n      JSON.stringify({\n        error: { code, message },\n        id: null,\n        jsonrpc: \"2.0\",\n      }),\n      {\n        headers: { \"Content-Type\": \"application/json\" },\n        status,\n      },\n    );\n  }\n\n  /**\n   * Handle initialize request\n   */\n  #handleInitialize(id: number | string): JSONRPCMessage {\n    return {\n      id,\n      jsonrpc: \"2.0\",\n      result: {\n        capabilities: {\n          prompts: this.#prompts.length > 0 ? {} : undefined,\n          resources: this.#resources.length > 0 ? {} : undefined,\n          tools: this.#tools.length > 0 ? {} : undefined,\n        },\n        protocolVersion: LATEST_PROTOCOL_VERSION,\n        serverInfo: {\n          name: this.#name,\n          version: this.#version,\n        },\n      },\n    } as JSONRPCMessage;\n  }\n\n  /**\n   * Handle MCP POST requests\n   */\n  async #handleMcpRequest(request: Request): Promise<Response> {\n    // Validate headers\n    const acceptHeader = request.headers.get(\"accept\");\n    if (\n      !acceptHeader?.includes(\"application/json\") &&\n      !acceptHeader?.includes(\"text/event-stream\")\n    ) {\n      return this.#errorResponse(\n        406,\n        -32000,\n        \"Not Acceptable: Client must accept application/json or text/event-stream\",\n      );\n    }\n\n    const contentType = request.headers.get(\"content-type\");\n    if (!contentType?.includes(\"application/json\")) {\n      return this.#errorResponse(\n        415,\n        -32000,\n        \"Unsupported Media Type: Content-Type must be application/json\",\n      );\n    }\n\n    // Parse request body\n    let body: unknown;\n    try {\n      body = await request.json();\n    } catch {\n      return this.#errorResponse(400, -32700, \"Parse error: Invalid JSON\");\n    }\n\n    // Handle single or batch requests\n    const messages = Array.isArray(body) ? body : [body];\n    const responses: JSONRPCMessage[] = [];\n\n    for (const message of messages) {\n      const response = await this.#handleMessage(message);\n      if (response) {\n        responses.push(response);\n      }\n    }\n\n    // Return appropriate response format\n    if (responses.length === 0) {\n      return new Response(null, { status: 202 });\n    }\n\n    const responseBody =\n      responses.length === 1\n        ? JSON.stringify(responses[0])\n        : JSON.stringify(responses);\n\n    return new Response(responseBody, {\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      status: 200,\n    });\n  }\n\n  /**\n   * Handle SSE GET requests\n   */\n  async #handleMcpSseRequest(request: Request): Promise<Response> {\n    const acceptHeader = request.headers.get(\"accept\");\n    if (!acceptHeader?.includes(\"text/event-stream\")) {\n      return this.#errorResponse(\n        406,\n        -32000,\n        \"Not Acceptable: Client must accept text/event-stream\",\n      );\n    }\n\n    // In stateless mode, GET requests are not supported (no server-initiated messages)\n    return this.#errorResponse(\n      405,\n      -32000,\n      \"Method Not Allowed: SSE streams not supported in stateless mode\",\n    );\n  }\n\n  /**\n   * Handle individual MCP messages\n   */\n  async #handleMessage(message: unknown): Promise<JSONRPCMessage | null> {\n    if (!message || typeof message !== \"object\") {\n      return this.#rpcError(null, -32700, \"Parse error: Invalid message\");\n    }\n\n    const msg = message as {\n      id?: number | string;\n      jsonrpc?: string;\n      method?: string;\n      params?: unknown;\n    };\n\n    if (msg.jsonrpc !== \"2.0\") {\n      return this.#rpcError(\n        msg.id ?? null,\n        -32600,\n        \"Invalid Request: jsonrpc must be 2.0\",\n      );\n    }\n\n    // Handle notifications (no response expected)\n    if (!(\"id\" in msg) || msg.id === undefined) {\n      return null;\n    }\n\n    const method = msg.method;\n    const id = msg.id;\n    const params = msg.params as Record<string, unknown> | undefined;\n\n    try {\n      switch (method) {\n        case \"initialize\":\n          return this.#handleInitialize(id);\n\n        case \"ping\":\n          return { id, jsonrpc: \"2.0\", result: {} } as JSONRPCMessage;\n\n        case \"prompts/get\":\n          return this.#handlePromptsGet(id, params);\n\n        case \"prompts/list\":\n          return this.#handlePromptsList(id);\n\n        case \"resources/list\":\n          return this.#handleResourcesList(id);\n\n        case \"resources/read\":\n          return this.#handleResourcesRead(id, params);\n\n        case \"tools/call\":\n          return this.#handleToolsCall(id, params);\n\n        case \"tools/list\":\n          return this.#handleToolsList(id);\n\n        default:\n          return this.#rpcError(id, -32601, `Method not found: ${method}`);\n      }\n    } catch (error) {\n      this.#logger.error(`Error handling ${method}:`, error);\n      return this.#rpcError(\n        id,\n        -32603,\n        `Internal error: ${error instanceof Error ? error.message : String(error)}`,\n      );\n    }\n  }\n\n  /**\n   * Handle prompts/get request\n   */\n  async #handlePromptsGet(\n    id: number | string,\n    params?: Record<string, unknown>,\n  ): Promise<JSONRPCMessage> {\n    const promptName = params?.name as string;\n    const promptArgs = params?.arguments as Record<string, string> | undefined;\n\n    const prompt = this.#prompts.find((p) => p.name === promptName);\n    if (!prompt) {\n      return this.#rpcError(\n        id,\n        ErrorCode.InvalidParams,\n        `Prompt not found: ${promptName}`,\n      );\n    }\n\n    try {\n      const result = await prompt.load(promptArgs ?? {});\n      const messages =\n        typeof result === \"string\"\n          ? [{ content: { text: result, type: \"text\" }, role: \"user\" }]\n          : result.messages;\n\n      return {\n        id,\n        jsonrpc: \"2.0\",\n        result: { messages },\n      } as JSONRPCMessage;\n    } catch (error) {\n      return this.#rpcError(\n        id,\n        ErrorCode.InternalError,\n        `Prompt load failed: ${error instanceof Error ? error.message : String(error)}`,\n      );\n    }\n  }\n\n  /**\n   * Handle prompts/list request\n   */\n  #handlePromptsList(id: number | string): JSONRPCMessage {\n    return {\n      id,\n      jsonrpc: \"2.0\",\n      result: {\n        prompts: this.#prompts.map((p) => ({\n          arguments: p.arguments,\n          description: p.description,\n          name: p.name,\n        })),\n      },\n    } as JSONRPCMessage;\n  }\n\n  /**\n   * Handle resources/list request\n   */\n  #handleResourcesList(id: number | string): JSONRPCMessage {\n    return {\n      id,\n      jsonrpc: \"2.0\",\n      result: {\n        resources: this.#resources.map((r) => ({\n          description: r.description,\n          mimeType: r.mimeType,\n          name: r.name,\n          uri: r.uri,\n        })),\n      },\n    } as JSONRPCMessage;\n  }\n\n  /**\n   * Handle resources/read request\n   */\n  async #handleResourcesRead(\n    id: number | string,\n    params?: Record<string, unknown>,\n  ): Promise<JSONRPCMessage> {\n    const uri = params?.uri as string;\n    const resource = this.#resources.find((r) => r.uri === uri);\n\n    if (!resource) {\n      return this.#rpcError(\n        id,\n        ErrorCode.InvalidParams,\n        `Resource not found: ${uri}`,\n      );\n    }\n\n    try {\n      const result = await resource.load();\n      const content =\n        typeof result === \"string\"\n          ? { mimeType: resource.mimeType ?? \"text/plain\", text: result, uri }\n          : { uri, ...result };\n\n      return {\n        id,\n        jsonrpc: \"2.0\",\n        result: { contents: [content] },\n      } as JSONRPCMessage;\n    } catch (error) {\n      return this.#rpcError(\n        id,\n        ErrorCode.InternalError,\n        `Resource load failed: ${error instanceof Error ? error.message : String(error)}`,\n      );\n    }\n  }\n\n  /**\n   * Handle tools/call request\n   */\n  async #handleToolsCall(\n    id: number | string,\n    params?: Record<string, unknown>,\n  ): Promise<JSONRPCMessage> {\n    const toolName = params?.name as string;\n    const toolArgs = params?.arguments as Record<string, unknown> | undefined;\n\n    const tool = this.#tools.find((t) => t.name === toolName);\n    if (!tool) {\n      return this.#rpcError(\n        id,\n        ErrorCode.InvalidParams,\n        `Tool not found: ${toolName}`,\n      );\n    }\n\n    try {\n      const result = await tool.execute(toolArgs ?? {});\n\n      // Normalize result to content array\n      const content =\n        typeof result === \"string\"\n          ? [{ text: result, type: \"text\" }]\n          : result.content;\n\n      return {\n        id,\n        jsonrpc: \"2.0\",\n        result: { content },\n      } as JSONRPCMessage;\n    } catch (error) {\n      return this.#rpcError(\n        id,\n        ErrorCode.InternalError,\n        `Tool execution failed: ${error instanceof Error ? error.message : String(error)}`,\n      );\n    }\n  }\n\n  /**\n   * Handle tools/list request\n   */\n  #handleToolsList(id: number | string): JSONRPCMessage {\n    return {\n      id,\n      jsonrpc: \"2.0\",\n      result: {\n        tools: this.#tools.map((tool) => ({\n          description: tool.description,\n          inputSchema: tool.parameters\n            ? this.#schemaToJsonSchema(tool.parameters)\n            : { type: \"object\" },\n          name: tool.name,\n        })),\n      },\n    } as JSONRPCMessage;\n  }\n\n  /**\n   * Create an RPC error message\n   */\n  #rpcError(\n    id: null | number | string,\n    code: number,\n    message: string,\n  ): JSONRPCMessage {\n    return {\n      error: { code, message },\n      id,\n      jsonrpc: \"2.0\",\n    } as JSONRPCMessage;\n  }\n\n  /**\n   * Convert schema to JSON Schema\n   */\n  #schemaToJsonSchema(\n    schema: StandardSchemaV1 | z.ZodType,\n  ): Record<string, unknown> {\n    try {\n      // Zod 4+: use native toJSONSchema if available\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      if (typeof (z as any).toJSONSchema === \"function\") {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return (z as any).toJSONSchema(schema) as Record<string, unknown>;\n      }\n      // Zod 3 fallback: use zod-to-json-schema\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      if (\"_def\" in (schema as any) || schema instanceof z.ZodType) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return zodToJsonSchema(schema as any, { target: \"openApi3\" }) as Record<\n          string,\n          unknown\n        >;\n      }\n      // For StandardSchema, fall back to a generic object schema\n      return { type: \"object\" };\n    } catch {\n      return { type: \"object\" };\n    }\n  }\n\n  /**\n   * Set up MCP and health routes\n   */\n  #setupRoutes(): void {\n    // Health endpoint\n    this.#honoApp.get(\"/health\", (c) => c.text(\"âœ“ Ok\"));\n\n    // MCP endpoint - handles all MCP protocol messages\n    this.#honoApp.post(this.#mcpPath, async (c) => {\n      return this.#handleMcpRequest(c.req.raw);\n    });\n\n    // MCP GET endpoint for SSE streams (server-initiated messages)\n    this.#honoApp.get(this.#mcpPath, async (c) => {\n      return this.#handleMcpSseRequest(c.req.raw);\n    });\n\n    // MCP DELETE endpoint for session termination\n    this.#honoApp.delete(this.#mcpPath, async () => {\n      return new Response(null, { status: 204 });\n    });\n  }\n}\n","/**\n * Web-standard Streamable HTTP Server Transport for MCP\n *\n * This transport implements the MCP Streamable HTTP specification using\n * web standard APIs (Request, Response, TransformStream) for compatibility\n * with edge runtimes like Cloudflare Workers, Deno, and Bun.\n */\n\nimport { Transport } from \"@modelcontextprotocol/sdk/shared/transport.js\";\nimport {\n  isInitializeRequest,\n  isJSONRPCNotification,\n  isJSONRPCResponse,\n  JSONRPCMessage,\n  JSONRPCMessageSchema,\n  MessageExtraInfo,\n  RequestId,\n} from \"@modelcontextprotocol/sdk/types.js\";\n\nexport type EventId = string;\n/**\n * Interface for resumability support via event storage\n */\nexport interface EventStore {\n  getStreamIdForEventId?(eventId: EventId): Promise<StreamId | undefined>;\n  replayEventsAfter(\n    lastEventId: EventId,\n    options: {\n      send: (eventId: EventId, message: JSONRPCMessage) => Promise<void>;\n    },\n  ): Promise<StreamId>;\n  storeEvent(streamId: StreamId, message: JSONRPCMessage): Promise<EventId>;\n}\n\nexport type StreamId = string;\n\n/**\n * Configuration options for WebStreamableHTTPServerTransport\n */\nexport interface WebStreamableHTTPServerTransportOptions {\n  /**\n   * If true, return JSON responses instead of SSE streams\n   */\n  enableJsonResponse?: boolean;\n\n  /**\n   * Event store for resumability support\n   */\n  eventStore?: EventStore;\n\n  /**\n   * Callback for session close events\n   */\n  onsessionclosed?: (sessionId: string) => Promise<void> | void;\n\n  /**\n   * Callback for session initialization events\n   */\n  onsessioninitialized?: (sessionId: string) => Promise<void> | void;\n\n  /**\n   * Function that generates a session ID for the transport.\n   * Return undefined to disable session management (stateless mode).\n   */\n  sessionIdGenerator: (() => string) | undefined;\n}\n\nconst MAXIMUM_MESSAGE_SIZE = 4 * 1024 * 1024; // 4MB\n\n/**\n * Web-standard Server transport for Streamable HTTP.\n * Uses web APIs (Request, Response, TransformStream) for edge runtime compatibility.\n */\nexport class WebStreamableHTTPServerTransport implements Transport {\n  onclose?: () => void;\n  onerror?: (error: Error) => void;\n  onmessage?: (message: JSONRPCMessage, extra?: MessageExtraInfo) => void;\n  sessionId?: string;\n  private _enableJsonResponse = false;\n  private _encoder = new TextEncoder();\n  private _eventStore?: EventStore;\n  private _onsessionclosed?: (sessionId: string) => Promise<void> | void;\n  private _onsessioninitialized?: (sessionId: string) => Promise<void> | void;\n  private _pendingResponses: JSONRPCMessage[] = [];\n  private _requestToStreamMapping = new Map<RequestId, StreamId>();\n\n  private _standaloneSseStreamId = \"_GET_stream\";\n  private _started = false;\n  private _streamMapping = new Map<\n    StreamId,\n    WritableStreamDefaultWriter<Uint8Array>\n  >();\n  private sessionIdGenerator: (() => string) | undefined;\n\n  constructor(options: WebStreamableHTTPServerTransportOptions) {\n    this.sessionIdGenerator = options.sessionIdGenerator;\n    this._enableJsonResponse = options.enableJsonResponse ?? false;\n    this._eventStore = options.eventStore;\n    this._onsessioninitialized = options.onsessioninitialized;\n    this._onsessionclosed = options.onsessionclosed;\n  }\n\n  /**\n   * Close the transport\n   */\n  async close(): Promise<void> {\n    for (const writer of this._streamMapping.values()) {\n      try {\n        await writer.close();\n      } catch {\n        // Ignore close errors\n      }\n    }\n    this._streamMapping.clear();\n    this._started = false;\n    this.onclose?.();\n  }\n\n  /**\n   * Handles an incoming web Request and returns a Response\n   */\n  async handleRequest(\n    request: Request,\n    parsedBody?: unknown,\n  ): Promise<Response> {\n    const method = request.method;\n\n    if (method === \"POST\") {\n      return this.handlePostRequest(request, parsedBody);\n    } else if (method === \"GET\") {\n      return this.handleGetRequest(request);\n    } else if (method === \"DELETE\") {\n      return this.handleDeleteRequest(request);\n    } else {\n      return this.handleUnsupportedRequest();\n    }\n  }\n\n  /**\n   * Send a message to connected clients\n   */\n  async send(\n    message: JSONRPCMessage,\n    options?: { relatedRequestId?: RequestId },\n  ): Promise<void> {\n    // Store for pending responses (used in JSON response mode)\n    this._pendingResponses.push(message);\n\n    // Send to SSE streams\n    const streamId = options?.relatedRequestId\n      ? this._requestToStreamMapping.get(options.relatedRequestId)\n      : this._standaloneSseStreamId;\n\n    if (streamId) {\n      const writer = this._streamMapping.get(streamId);\n      if (writer) {\n        try {\n          if (this._eventStore) {\n            const eventId = await this._eventStore.storeEvent(\n              streamId,\n              message,\n            );\n            await this.writeSSEEventWithId(writer, eventId, message);\n          } else {\n            await this.writeSSEEvent(writer, message);\n          }\n        } catch (error) {\n          this.onerror?.(\n            error instanceof Error ? error : new Error(String(error)),\n          );\n        }\n      }\n    }\n  }\n\n  async start(): Promise<void> {\n    if (this._started) {\n      throw new Error(\"Transport already started\");\n    }\n    this._started = true;\n  }\n\n  /**\n   * Create an error response\n   */\n  private createErrorResponse(\n    status: number,\n    code: number,\n    message: string,\n  ): Response {\n    return new Response(\n      JSON.stringify({\n        error: { code, message },\n        id: null,\n        jsonrpc: \"2.0\",\n      }),\n      {\n        headers: {\n          ...this.getResponseHeaders(),\n          \"Content-Type\": \"application/json\",\n        },\n        status,\n      },\n    );\n  }\n\n  /**\n   * Get common response headers\n   */\n  private getResponseHeaders(): Record<string, string> {\n    const headers: Record<string, string> = {};\n    if (this.sessionId) {\n      headers[\"mcp-session-id\"] = this.sessionId;\n    }\n    return headers;\n  }\n\n  /**\n   * Handles DELETE requests to terminate sessions\n   */\n  private async handleDeleteRequest(request: Request): Promise<Response> {\n    const sessionId = request.headers.get(\"mcp-session-id\");\n\n    if (this.sessionIdGenerator) {\n      if (!sessionId) {\n        return this.createErrorResponse(\n          400,\n          -32000,\n          \"Bad Request: Mcp-Session-Id header is required\",\n        );\n      }\n\n      if (this.sessionId !== sessionId) {\n        return this.createErrorResponse(404, -32001, \"Session not found\");\n      }\n    }\n\n    // Close all streams\n    for (const writer of this._streamMapping.values()) {\n      try {\n        await writer.close();\n      } catch {\n        // Ignore close errors\n      }\n    }\n    this._streamMapping.clear();\n\n    await this._onsessionclosed?.(this.sessionId ?? \"\");\n    this.sessionId = undefined;\n\n    return new Response(null, {\n      headers: this.getResponseHeaders(),\n      status: 204,\n    });\n  }\n\n  /**\n   * Handles GET requests for SSE stream\n   */\n  private async handleGetRequest(request: Request): Promise<Response> {\n    const acceptHeader = request.headers.get(\"accept\");\n    if (!acceptHeader?.includes(\"text/event-stream\")) {\n      return this.createErrorResponse(\n        406,\n        -32000,\n        \"Not Acceptable: Client must accept text/event-stream\",\n      );\n    }\n\n    // Validate session\n    const sessionId = request.headers.get(\"mcp-session-id\");\n    if (this.sessionIdGenerator && !sessionId) {\n      return this.createErrorResponse(\n        400,\n        -32000,\n        \"Bad Request: Mcp-Session-Id header is required\",\n      );\n    }\n\n    if (this.sessionIdGenerator && this.sessionId !== sessionId) {\n      return this.createErrorResponse(404, -32001, \"Session not found\");\n    }\n\n    // Check for existing standalone stream\n    if (this._streamMapping.has(this._standaloneSseStreamId)) {\n      return this.createErrorResponse(\n        409,\n        -32000,\n        \"Conflict: SSE stream already exists for this session\",\n      );\n    }\n\n    // Handle resumability\n    if (this._eventStore) {\n      const lastEventId = request.headers.get(\"last-event-id\");\n      if (lastEventId) {\n        return this.handleReplayEvents(lastEventId);\n      }\n    }\n\n    // Create SSE stream\n    const { readable, writable } = new TransformStream<Uint8Array>();\n    const writer = writable.getWriter();\n    this._streamMapping.set(this._standaloneSseStreamId, writer);\n\n    return new Response(readable, {\n      headers: {\n        ...this.getResponseHeaders(),\n        \"Cache-Control\": \"no-cache, no-transform\",\n        Connection: \"keep-alive\",\n        \"Content-Type\": \"text/event-stream\",\n      },\n      status: 200,\n    });\n  }\n\n  /**\n   * Handles POST requests containing JSON-RPC messages\n   */\n  private async handlePostRequest(\n    request: Request,\n    parsedBody?: unknown,\n  ): Promise<Response> {\n    // Validate Accept header\n    const acceptHeader = request.headers.get(\"accept\");\n    if (\n      !acceptHeader?.includes(\"application/json\") &&\n      !acceptHeader?.includes(\"text/event-stream\")\n    ) {\n      return this.createErrorResponse(\n        406,\n        -32000,\n        \"Not Acceptable: Client must accept application/json or text/event-stream\",\n      );\n    }\n\n    // Validate Content-Type\n    const contentType = request.headers.get(\"content-type\");\n    if (!contentType?.includes(\"application/json\")) {\n      return this.createErrorResponse(\n        415,\n        -32000,\n        \"Unsupported Media Type: Content-Type must be application/json\",\n      );\n    }\n\n    // Validate Content-Length\n    const contentLength = parseInt(\n      request.headers.get(\"content-length\") ?? \"0\",\n      10,\n    );\n    if (contentLength > MAXIMUM_MESSAGE_SIZE) {\n      return this.createErrorResponse(\n        413,\n        -32000,\n        `Request body too large. Maximum size is ${MAXIMUM_MESSAGE_SIZE} bytes`,\n      );\n    }\n\n    // Parse body\n    let rawMessage: unknown;\n    try {\n      rawMessage = parsedBody ?? (await request.json());\n    } catch {\n      return this.createErrorResponse(400, -32700, \"Parse error: Invalid JSON\");\n    }\n\n    // Handle batch or single message\n    const arrayMessage: unknown[] = Array.isArray(rawMessage)\n      ? rawMessage\n      : [rawMessage];\n\n    // Validate messages\n    const messages: JSONRPCMessage[] = [];\n    for (const msg of arrayMessage) {\n      const result = JSONRPCMessageSchema.safeParse(msg);\n      if (!result.success) {\n        return this.createErrorResponse(\n          400,\n          -32700,\n          \"Parse error: Invalid JSON-RPC message\",\n        );\n      }\n      messages.push(result.data);\n    }\n\n    // Handle session ID\n    const requestSessionId = request.headers.get(\"mcp-session-id\");\n    const hasInitRequest = messages.some((msg) => isInitializeRequest(msg));\n\n    // Validate session requirements\n    if (hasInitRequest && requestSessionId) {\n      return this.createErrorResponse(\n        400,\n        -32600,\n        \"Invalid Request: Initialization requests must not include a sessionId\",\n      );\n    }\n\n    if (hasInitRequest && messages.length > 1) {\n      return this.createErrorResponse(\n        400,\n        -32600,\n        \"Invalid Request: Only one initialization request is allowed\",\n      );\n    }\n\n    if (!hasInitRequest && !requestSessionId && this.sessionIdGenerator) {\n      return this.createErrorResponse(\n        400,\n        -32000,\n        \"Bad Request: Mcp-Session-Id header is required\",\n      );\n    }\n\n    // Generate or validate session ID\n    if (hasInitRequest && this.sessionIdGenerator) {\n      this.sessionId = this.sessionIdGenerator();\n      await this._onsessioninitialized?.(this.sessionId);\n    } else if (requestSessionId) {\n      if (this.sessionIdGenerator && this.sessionId !== requestSessionId) {\n        return this.createErrorResponse(404, -32001, \"Session not found\");\n      }\n    }\n\n    // Process messages through the transport\n    this._pendingResponses = [];\n    for (const message of messages) {\n      this.onmessage?.(message, { authInfo: undefined });\n    }\n\n    // If all messages are notifications/responses, return 202\n    if (\n      messages.every(\n        (msg) => isJSONRPCNotification(msg) || isJSONRPCResponse(msg),\n      )\n    ) {\n      return new Response(null, {\n        headers: this.getResponseHeaders(),\n        status: 202,\n      });\n    }\n\n    // Return JSON response if enabled and client accepts it\n    if (\n      this._enableJsonResponse &&\n      acceptHeader?.includes(\"application/json\")\n    ) {\n      // Wait a tick for responses to be collected\n      await new Promise((resolve) => setTimeout(resolve, 0));\n\n      const responseBody =\n        this._pendingResponses.length === 1\n          ? JSON.stringify(this._pendingResponses[0])\n          : JSON.stringify(this._pendingResponses);\n\n      return new Response(responseBody, {\n        headers: {\n          ...this.getResponseHeaders(),\n          \"Content-Type\": \"application/json\",\n        },\n        status: 200,\n      });\n    }\n\n    // Return SSE stream\n    const { readable, writable } = new TransformStream<Uint8Array>();\n    const writer = writable.getWriter();\n    const streamId = `post_${Date.now()}`;\n    this._streamMapping.set(streamId, writer);\n\n    // Send any pending responses as SSE events\n    (async () => {\n      try {\n        for (const response of this._pendingResponses) {\n          await this.writeSSEEvent(writer, response);\n        }\n      } catch (error) {\n        this.onerror?.(\n          error instanceof Error ? error : new Error(String(error)),\n        );\n      }\n    })();\n\n    return new Response(readable, {\n      headers: {\n        ...this.getResponseHeaders(),\n        \"Cache-Control\": \"no-cache, no-transform\",\n        Connection: \"keep-alive\",\n        \"Content-Type\": \"text/event-stream\",\n      },\n      status: 200,\n    });\n  }\n\n  /**\n   * Replay events for resumability\n   */\n  private async handleReplayEvents(lastEventId: string): Promise<Response> {\n    if (!this._eventStore) {\n      return this.createErrorResponse(\n        400,\n        -32000,\n        \"Resumability not supported\",\n      );\n    }\n\n    const { readable, writable } = new TransformStream<Uint8Array>();\n    const writer = writable.getWriter();\n\n    try {\n      const streamId = await this._eventStore.replayEventsAfter(lastEventId, {\n        send: async (eventId, message) => {\n          await this.writeSSEEventWithId(writer, eventId, message);\n        },\n      });\n      this._streamMapping.set(streamId, writer);\n    } catch (error) {\n      await writer.close();\n      return this.createErrorResponse(500, -32000, `Replay failed: ${error}`);\n    }\n\n    return new Response(readable, {\n      headers: {\n        ...this.getResponseHeaders(),\n        \"Cache-Control\": \"no-cache, no-transform\",\n        Connection: \"keep-alive\",\n        \"Content-Type\": \"text/event-stream\",\n      },\n      status: 200,\n    });\n  }\n\n  /**\n   * Handles unsupported HTTP methods\n   */\n  private handleUnsupportedRequest(): Response {\n    return this.createErrorResponse(405, -32000, \"Method not allowed\");\n  }\n\n  /**\n   * Write an SSE event to the stream\n   */\n  private async writeSSEEvent(\n    writer: WritableStreamDefaultWriter<Uint8Array>,\n    message: JSONRPCMessage,\n  ): Promise<void> {\n    const data = `data: ${JSON.stringify(message)}\\n\\n`;\n    await writer.write(this._encoder.encode(data));\n  }\n\n  /**\n   * Write an SSE event with ID to the stream\n   */\n  private async writeSSEEventWithId(\n    writer: WritableStreamDefaultWriter<Uint8Array>,\n    eventId: string,\n    message: JSONRPCMessage,\n  ): Promise<void> {\n    const data = `id: ${eventId}\\ndata: ${JSON.stringify(message)}\\n\\n`;\n    await writer.write(this._encoder.encode(data));\n  }\n}\n"],"mappings":"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","names":[]}